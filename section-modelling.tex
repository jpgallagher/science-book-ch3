\nopagebreak
\section{Energy Modelling}\label{sec:energy-models}

An energy model provides information on the energy consumed when running a program on a given hardware platform, based on parameters that characterise the program and its execution. The energy model contains measured energy consumption costs for these parameters and links these costs with program specific values for the parameters to arrive at an overall energy consumption estimation. 

Models that support software energy analysis typically associate program constructs, such as source code blocks, basic blocks in the intermediate representation of the program used during compilation or machine code instructions, with energy consumption costs. In addition, other costs arising from the execution of a program may need to be considered, depending on the micro architectural features of the hardware; examples are costs associated with the memory hierarchy, such as the cost of a cache hit and miss or the cost of accessing on-chip and off-chip memory, and also costs associated with the processor pipeline, such as the cost of pipeline stalls. In addition, the cost of the processor being idle and the cost of processing multiple threads concurrently may also need to be considered. 
%
In general, to instantiate an energy model, model parameters can be obtained either from analyzing execution or simulation traces, e.g.\ counting instructions, cache hits and misses, etc, or through static analysis as will be discussed next, in Section~\ref{sec:energy-analysis}.


The challenge in energy modelling for software energy analysis is in finding a good compromise between the accuracy of the model and the ease with which the information can be mapped onto software constructs. Regarding the former, model accuracy tends to be higher for models at the lower-levels of abstraction, i.e.\ instruction-level energy models are typically more accurate than energy models at the intermediate representation of the compiler, and source code energy models are least accurate in comparison. However, understanding which source code lines or blocks consume most energy is much more useful to software developers looking to optimise their code for energy efficiency, than knowing the energy consumed by the sequence of machine instructions issued by the compiler. The higher the level of abstraction at which the information is presented to the software developer, the easier it is for them to comprehend the impact of algorithms and coding on the energy consumed during program execution.



\subsection{Defining and constructing an energy model at ISA level}

The Instruction Set Architecture (ISA) is a practical level of abstraction for modelling, because it expresses
underlying hardware operations and their relationship with the intent of the
software. Constructing a model at this level gives us the following benefits:
energy costs can be assigned at the instruction level; the same level
    as is output by the compiler;
 there are strong correlations between instruction properties and energy
    consumption, for example the number of operands used in the instruction;
and machine instructions can be related back to the original programming
    statements written by the software developer, as well as to various
    intermediate representations.

The construction of an energy model at the ISA level has to address several challenges.
 Instruction costs must be captured through a profiling suite and
    measurement of device power. However, not all instructions can be directly profiled, requiring indirect or
    statistical approaches to their characterisation.
In addition, other properties such as the cost of running multiple threads and the cost of idle periods must be determined for multi-threaded architectures.

\subsection{Energy modelling at higher levels of software abstraction}
\label{subsec:mapping}

Modelling at the level of the Intermediate Representation (IR) 
used by compilers can be a useful compromise between the accuracy of a lower-level (ISA) 
model and the to high-level source code. Since the compiler is a natural
place for optimisations, modelling and predicting the energy consumption at
IR level could therefore enable energy specific optimisations.

Using a mapping technique, 
the energy model at the ISA level can be lifted to the LLVM IR level, allowing energy
consumption estimation of programs at that level. 
The mapping technique determines the energy characteristics of LLVM IR
instructions. It provides on-the-fly energy characterization that takes into
consideration the context of instructions since there is no program-independent mapping between
ISA instructions and LLVM instructions.

In principle, the same mapping technique may be used to map the energy consumption
of programs to even higher levels, such as the source code. 


An alternative approach to building a source-level energy model is to identify
basic energy-consuming operations from the source code and
correlate them to energy costs by measuring energy consumption in
a large number of test cases and analyzing the results using techniques
based on regression analysis. The resulting energy model of the basic
operations implicitly includes the effect of all the layers of the software
stack down to the hardware, including compiled code, virtual machine and operating
system layers. The approach is inherently approximate;
nevertheless such an approach may be the only feasible one in cases where the software
stack has many complex layers. 


